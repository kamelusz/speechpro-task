# Задача
## Статус

| Reference | Windows | Linux | 
|:--------:|:---------:|:-------------:|
|[![Documentation](https://codedocs.xyz/kamelusz/speechpro-task.svg)](https://codedocs.xyz/kamelusz/speechpro-task/)|[![Build status](https://ci.appveyor.com/api/projects/status/2lln20tsy8mafo22/branch/master?svg=true)](https://ci.appveyor.com/project/kamelusz/speechpro-task/branch/master)|[![Build Status](https://travis-ci.org/kamelusz/speechpro-task.svg?branch=master)](https://travis-ci.org/kamelusz/speechpro-task)|

Необходимо написать программу, считающую интегральные изображения входных изображений.
Интегральное изображение (integral image):
* для C-канального изображения размером H строк на W столбцов Image интегральным изображением является следующее C-канальное изображение Integral размером H строк на W столбцов с типом данных double, для которого Integral(channel, row, col) = Sum(Image(channel, [0:row], [0:col]));
* то есть значение пикселя в новом изображении равно сумме пикселей выше и левее него (нестрого);
* если в исходном изображении каналов несколько, то, например, первый канал интегрального изображения будет равен интегральному изображению первого канала;

Пример: для одноканального изображения
```
0 1
2 3
4 5
```
интегральным будет являться изображение
```
0.0 1.0
2.0 6.0
6.0 15.0
```

## Теперь про приложение
* приложение должно называться integral_image;
* запускаться должно следующим образом: ./integral_image -i <path_to_image2> [-i <path_to_image2> […]] [-t <threads number>], где -i указывает путь до изображения (таких аргументов может быть несколько), -t указывает количество потоков, которое желательно использовать;
* аргумент -t может быть равен 0, в этом случае необходимо автоматически выбрать количество потоков, исходя из возможностей процессора;
* аргумент -t может отстутствовать, в этом случае его считать равным 0;
* гарантируется, что будет не более одного аргумента -t;
* аргументы могут идти в любом порядке;
* аргументов -i может быть сколько угодно;
* при указании некорректного количества потоков приложение должно ничего не сделать, вывести сообщение об ошибке и корректно завершиться;
* при указании некорректного пути, например, path_to_image2, оно не должно обрабатываться, должно быть выведено сообщение об ошибке с этим изображением, при этом результат должен быть посчитан для всех изображений с корректными путями;
* интегральное изображение для изображения path_to_image2 стоит записать в текстовый файл path_to_image2.integral в следующем формате: интегральное изображение для первого канала, пустая строка, интегральное изображение для второго канала, если оно есть, и пустая строка и т.д. (для всех каналов);
* для изображения из примера выше приложение должно вывести следующее:
```
0.0 1.0
2.0 6.0
6.0 15.0
```

## Требования к реализации
* должны присутствовать юнит-тесты. Допускается использование любого юнит-тест фремворка (можно Catch (https://github.com/philsquared/Catch) или GoogleTest (https://github.com/google/googletest) как наиболее легко подключаемые);
* код должен быть документирован в формате Doxygen, комментарии в реализации должны пояснять другим разработчикам детали неочевидных особенностей реализации;
* в качестве системы сборки должен использоваться CMake (https://cmake.org/).

## Можно использовать любые опенсорсные библиотеки со следующими условиями
* нельзя использовать готовую реализацию алгоритма вычисления интегрального изображения;
* они должны автоматически подключаться через CMake (разумеется, при условии выставления необходимых флагов командной строки CMake и их наличия в ОС);
* для считывания изображений и базовой работы с ними рекомендуется использовать OpenCV 3.x.

## Приветствуется
* максимальная кроссплатформенность кода, в качестве целевых компиляторов можно рассматривать Visual Studio 2013 (или выше) и GCC 5.x (или выше);
* максимальное (но разумное) использование структур и алгоритмов стандартной библиотеки;
* использование стандартов C++11 и C++14;
* распараллеливание даже если на вход подаётся всего одно изображение